    alloc 1024 ;; allocates 1024 bytes of memory on the heap
    pushu0 ;; tape pointer
    pushu0 ;; code pointer
    scans
    swap 2
    swap 1

Loop:
    dup 0
    dup 3
    add
    readc
    call ParseInst
    dup 0
    dup 3
    add
    readc
    push '\0'
    je FinishProg
    pop
    inc
    jmp Loop


ParseInst:
    swap 1
    dup 0
    push '+'
    je ParsePlus
    dup 0
    push '-'
    je ParseMinus
    dup 0
    push '<'
    je ParseLess
    dup 0
    push '>'
    je ParseGreat
    dup 0
    push ','
    je ParseComma
    dup 0
    push '.'
    je ParsePeriod
    dup 0
    push '['
    je ParseLsq
    dup 0
    push ']'
    je ParseRsq
    pop
    swap 1
    pop
    ret


ParsePlus:
    pop
    dup 5
    dup 4
    add
    readc
    inc
    writec
    pop
    swap 1
    pop
    ret ;; return ParseInst


ParseMinus:
    pop
    dup 5
    dup 4
    add
    readc
    dec
    writec
    pop
    swap 1
    pop
    ret ;; return ParseInst


ParseLess:
    pop
    swap 3
    dup 0
    pushu0
    lte
    swap 2
    pop
    swap 1
    jf DecTapePtr
    swap 2
    ret ;; return ParseInst

DecTapePtr:
    dec
    swap 2
    ret ;; return ParseInst


ParseGreat:
    pop
    swap 3
    dup 0
    push 1023u ;; maximum location of the tape pointer
    gte
    swap 2
    pop
    swap 1
    jf IncTapePtr
    swap 2
    ret ;; return ParseInst

IncTapePtr:
    inc
    swap 2
    ret ;; return ParseInst


ParseComma:
    pop
    scanc
    dup 6
    dup 5
    add
    swap 1
    writec
    pop
    swap 1
    pop
    ret ;; return ParseInst


ParsePeriod:
    pop
    dup 5
    dup 4
    add
    readc
    print
    pop
    swap 1
    pop
    ret ;; return ParseInst


ParseLsq:
    pop
    dup 5 ;; copies tape
    dup 4 ;; copies tapePtr
    add ;; HeapPtr(tape + tapePtr)
    readc
    push '\0'
    je findRsq ;; if (current tape data) == 0
    pop
    swap 1
    pop
    ret ;; return ParseInst

findRsq:
    pop
    swap 1
    dup 0 ;; copies HeapPtr(code + codePtr)
    pushu0 ;; codePtrMove
    inc ;; ++codePtrMove
    pushu1 ;; nestedCount
    swap 2
    inc ;; ++(copied (code + codePtr))
    ;; check whether given character is [ or ]
checkCurrentCodeChar:
    readc
    push '['
    je incNestedCount
    readc
    push ']'
    je decNestedCount
    readc
    push '\0'
    je exitfindRsq
moveNext:
    inc ;; ++(copied (code + codePtr))
    swap 1
    inc ;; ++codePtrMove
    swap 1
    jmp checkCurrentCodeChar
    ;; program crash
exitfindRsq:
    swap 8
    free
    swap 6
    free
    halt

incNestedCount:
    swap 2
    inc
    swap 2
    jmp moveNext
decNestedCount:
    swap 2
    dup 0
    pushu1
    rje 4 ;; goto <checkpoint1>
    dec
    swap 2
    jmp moveNext
    pop ;; <checkpoint1>
    swap 3
    swap 2
    pop
    pop
    swap 2
    add
    swap 1
    ret ;; return ParseInst
;; end ParseLsq


ParseRsq:
    pop
    dup 5 ;; copies tape
    dup 4 ;; copies tapePtr
    add ;; HeapPtr(tape + tapePtr)
    readc
    push '\0'
    jne findLsq ;; if (current tape data) != 0
    pop
    swap 1
    pop
    ret ;; return ParseInst

findLsq:
    pop
    swap 1
    dup 0 ;; copies HeapPtr(code + codePtr)
    pushu0 ;; codePtrMove
    inc ;; ++codePtrMove
    pushu1 ;; nestedCount
    swap 2
    dec ;; --(copied (code + codePtr))
    ;; check whether given character is [ or ]
checkCurrentCodeChar_:
    readc
    push ']'
    je incNestedCount_
    readc
    push '['
    je decNestedCount_
    readc
    push '\0'
    je exitfindLsq
moveNext_:
    dec ;; --(copied (code + codePtr))
    swap 1
    inc ;; ++codePtrMove
    swap 1
    jmp checkCurrentCodeChar_
    ;; program crash
exitfindLsq:
    swap 8
    free
    swap 6
    free
    halt

incNestedCount_:
    swap 2
    inc
    swap 2
    jmp moveNext_
decNestedCount_:
    swap 2
    dup 0
    pushu1
    rje 4 ;; goto <checkpoint2>
    dec
    swap 2
    jmp moveNext_
    pop ;; <checkpoint2>
    swap 3
    swap 2
    pop
    pop
    swap 2
    swap 1
    sub
    swap 1
    ret ;; return ParseInst
;; end ParseRsq

FinishProg:
    pop
    pop
    pop
    free
    free
    push '\n'
    print
    halt

